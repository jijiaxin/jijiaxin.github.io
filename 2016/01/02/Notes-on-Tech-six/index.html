	<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>盗墓笔记（六） | 微凉一季</title>
  <meta name="author" content="季訫">
  
  <meta name="description" content="往事如烟，随风而逝">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="盗墓笔记（六）"/>
  <meta property="og:site_name" content="微凉一季"/>

  
  
		<!-- favicon -->
		<link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
		<link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
		<link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
		<link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
		<link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
		<link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
		<link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
		<link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
		<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
		<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
		<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.png">
		<meta name="theme-color" content="#009688">
		<!-- favicon end -->
    <!-- <link href="/favicon.ico" rel="icon"> -->
  

  <!-- toc -->
  <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css">

  <!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">

  <!-- material design -->
	<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css">
  <!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
	<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  
  <!-- 百度统计 -->
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?965a6e7fe7dbf925b4191360c79b5e64";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  

  

  <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>
	<script>window.jQuery || document.write('<script src="/libs/jquery-2.0.3.min.js" type="text/javascript"><\/script>')</script>

</head>

 	<body>
	  <nav class="navbar navbar-default">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">菜单</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">微凉一季</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    <a href="/" title="">
                    <i class="fa fa-home"></i>首页
                    </a>
                </li>
                
                <li>
                    <a href="/archives" title="">
                    <i class="fa fa-list"></i>存档
                    </a>
                </li>
                
                <li>
                    <a href="/about" title="">
                    <i class="fa fa-info-circle"></i>关于
                    </a>
                </li>
                
                <li>
                    <a href="/atom.xml" title="这是一个订阅源">
                    <i class="fa fa-rss"></i>RSS
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</nav>

	  <div class="container" >
	    <div class="row">
	
	<div class="col-md-9 center-content">
	

		<div class="content">
			<!-- index -->
		   

			  		<h2>盗墓笔记（六）</h2>
					
					<div>
						<span class="post-time">2016-01-02 20:24:51</span>
					</div>	
					

					<div class="article-content">
						<p>2016年第一篇笔记，也是总第6篇笔记。加油，随笔。</p>
<h3 id="01-02号-周六"><a href="#01-02号-周六" class="headerlink" title="01/02号  周六"></a>01/02号  周六</h3><p>物联网（Internet of Things）简写作Iots </p>
<p>onMesure会被调用多次，onLayout会被调用一次，更轻量级，所以可以把耗时处理操作尽量从onMeasure往onLayout中移过来。<br>requestLayout只重新布局，invalidate会调用ondraw，postInvalidate供子线程调用。<br>onDraw只考虑绘制内容区域，背景什么的不要管。<br>一般情况下:自定义view考虑onMeasure和onDraw;自定义viewGroup考虑onMeasure和onLayout,不需要考虑onDraw。有交互的时候考虑onTouchEvent。<br>第一个手指触控时候，第二个手指触控会夺取控制权，这时候第三个手指触控会第三个手指拥有控制权，此时第三个手指抬起后，第一个手机将获得控制权。<br><a id="more"></a><br>静态成员变量属于类不属于对象，所以不会参与序列化过程；用transient(瞬时的)关键字标记的成员变量不参与序列化过程。<br>系统已经为我们提供了很多实现了Parcelable接口的类，他们都是可以直接序列化的，比如：Intent，Bundle，Bitmap等，同时List和Map也可以序列化，前提是他们里面的每个元素都是可以序列化的。</p>
<h3 id="01-03号-周天"><a href="#01-03号-周天" class="headerlink" title="01/03号  周天"></a>01/03号  周天</h3><p>HttpUrlConnection 在 2.3 以前的版本是有 bug 的，所以之前的版本推荐使用 HttpClient，但是 google 现在已经不维护 HttpClient 了，5.1里面已经把 HttpClient 标过期。另外 HttpURLConnection 支持gzip压缩等，推荐首选它。<br><a href="http://blog.csdn.net/yaozhifeng123456/article/details/48465091" target="_blank" rel="external">HttpURLConnection 与 Android HttpClient 对比</a></p>
<p>okhttp是folk的HttpUrlConnection</p>
<h3 id="01-04号-周一"><a href="#01-04号-周一" class="headerlink" title="01/04号  周一"></a>01/04号  周一</h3><p>CRLF代表回车换行<br>关于为什么用CRLF代表回车换行，则要提一下一个历史问题，相信大家在电视上看美国一些老电影的时候都看过打字员使用打字机的场景，当打字到一行尾部的时候，机器会有两个操作，一个是打印的针头会调回到开始处；另一个是打印纸同时会向下移动一行。对于前者就叫做Carriage Return（Carriage Return可以翻译为机器滑动的部分回到开始处）简写即为CR；而后者就叫做Line Feed（Line Feed有行满的意思），简称LF。所以在没有计算机之前，需要同时使用CRLF来表示起一个新行。</p>
<p>defaultConfig方法包含了该app的核心属性，该属性会重写在AndroidManifest.xml中的对应属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">defaultConfig &#123;</div><div class="line">       applicationId <span class="string">"com.gradleforandroid.gettingstarted"</span></div><div class="line">       minSdkVersion <span class="number">14</span></div><div class="line">       targetSdkVersion <span class="number">22</span></div><div class="line">       versionCode <span class="number">1</span></div><div class="line">       versionName <span class="string">"1.0"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Gradle能够很轻松的构建不同版本的app,使用构建变种。举个例子，其能够很轻松的创建一个免费版本和付费版本的app。这两个版本需要分隔的标示码，所以他们能够以不同的app出现在各大应用商店，当然他们也能够同时安装在一个手机中。资源代码和R文件必须拥有相同的包名，否则你的资源代码将需要改变，这就是为什么Android开发团队要将package name的两大功能拆分开。在AndroidManifest文件中定义的package name依然被用来作为包名和R文件的包名。而applicationid将被用在设备和各大应用商店中作为唯一的标示。<br>android插件依赖于Java插件，而Java插件依赖于base插件。</p>
<p>基本的tasks<br>base插件有基本的tasks生命周期和一些通用的属性。<br>base插件定义了例如assemble和clean任务，Java插件定义了check和build任务，这两个任务不在base插件中定义。<br>这些tasks的约定含义：<br>assemble: 集合所有的output<br>clean: 清除所有的output<br>check: 执行所有的checks检查，通常是unit测试和instrumentation测试<br>build: 执行所有的assemble和check<br>Java插件同时也添加了source sets的概念。</p>
<p>Android tasks<br>android插件继承了这些基本tasks,并且实现了他们自己的行为：<br>assemble 针对每个版本创建一个apk<br>clean 删除所有的构建任务，包含apk文件<br>check 执行Lint检查并且能够在Lint检测到错误后停止执行脚本<br>build 执行assemble和check</p>
<p>使用aar文件<br>如果你想复用你的library，那么你就可以创建一个aar文件，并将其作为你的工程依赖。当你构建你的library项目，aar文件将会在 build/output/aar/下生成。把该文件作为你的依赖包，你需要创建一个文件夹来放置它，我们就叫它aars文件夹吧，然后把它拷贝到该文件夹里面，然后添加该文件夹作为依赖库：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">repositories &#123;</div><div class="line">    flatDir &#123;</div><div class="line">        dirs <span class="string">'aars'</span> </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样你就可以把该文件夹下的所有aar文件作为依赖，同时你可以这么干：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">       compile(<span class="string">name:</span><span class="string">'libraryname'</span>, <span class="string">ext:</span><span class="string">'aar'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有些时候，你可能需要和sdk协调工作。为了能顺利编译你的代码，你需要添加SDK到你的编译环境。你不需要将sdk包含在你的APK中，因为它早已经存在于设备中，所以配置来啦，我们会有5个不同的配置：</p>
<p>compile<br>apk<br>provided<br>testCompile<br>androidTestCompile</p>
<p>compile是默认的那个，其含义是包含所有的依赖包，即在APK里，compile的依赖会存在。<br>apk的意思是apk中存在，但是不会加入编译中，这个貌似用的比较少。<br>provided的意思是提供编译支持，但是不会写入apk。<br>testCompile和androidTestCompile会添加额外的library支持针对测试。</p>
<p>在一些情形中，你可能想使用最新的依赖包在构建你的app或者library的时候。实现他的最好方式是使用动态版本。我现在给你们展示几种不同的动态控制版本方式：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">       compile <span class="string">'com.android.support:support-v4:22.2.+'</span></div><div class="line">       compile <span class="string">'com.android.support:appcompat-v7:22.2+'</span></div><div class="line">       compile <span class="string">'com.android.support:recyclerview-v7:+'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一行，我们告诉gradle,得到最新的生产版本。第二行，我们告诉gradle，我们想得到最新的minor版本，并且其最小的版本号是2. 第三行，我们告诉gradle,得到最新的library。<br>你应该小心去使用动态版本，如果当你允许gradle去挑选最新版本，可能导致挑选的依赖版本并不是稳定版，这将会对构建产生很多问题，更糟糕的是你可能在你的服务器和私人pc上得到不同的依赖版本，这直接导致你的应用不同步。</p>
<h3 id="01-07号-周四"><a href="#01-07号-周四" class="headerlink" title="01/07号  周四"></a>01/07号  周四</h3><p>abstract不能与final并列修饰同一个类。<br>abstract不能与private、static、final或native并列修饰同一个方法。</p>
<p>接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字，他表示该类在遵循某个或某组特定的接口，同时也表示着“interface只是它的外貌，但是现在需要声明它是如何工作的”。</p>
<p>一个Interface的方所有法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！<br>接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name。<br>可以使用 instanceof 检查一个对象是否实现了某个特定的接口。例如：if(anObject instanceof Comparable){}。</p>
<h3 id="01-08号-周五"><a href="#01-08号-周五" class="headerlink" title="01/08号  周五"></a>01/08号  周五</h3><p>private final String TAG = this.getClass().getSimpleName();</p>
<p>requestLayout()方法会调用measure过程和layout过程<br>onLayout中setbitmap会调用requestLayout(),所以要post延时一下，等待onLayout完毕再setBitmap。</p>
<p>ViewRoot对应于ViewRootImpl类，他是连接WindowManager和DecorView的纽带，View的三大流程均通过ViewRoot来完成的。在ActivityThread中，当Activity对象被创建完毕后，会将DecorView添加到Window中，同时创建ViewRootImpl对象，并将ViewRootImpl和DecorView建立关联。<br>DecorView其实是一个FrameLayout，view的事件都是先经过DecorView，然后传递给我们的view。</p>
<h3 id="01-10号-周天"><a href="#01-10号-周天" class="headerlink" title="01/10号  周天"></a>01/10号  周天</h3><p>minSdkVersion 和 targetSdkVersion会被包含进最终的 APK 文件中，如果你查看生成的 AndroidManifest.xml 文件，你会看到类似下面这样的标签：<br><code>&lt;uses-sdk android:targetSdkVersion=&quot;23&quot; android:minSdkVersion=&quot;7&quot; /&gt;</code><br>compileSdkVersion 不会包含进去,compileSdkVersion应该保持是最新的。<br><code>minSdkVersion &lt;= targetSdkVersion &lt;= compileSdkVersion</code><br>理想上，在稳定状态下三者的关系应该更像这样：<br><code>minSdkVersion (lowest possible) &lt;= 
    targetSdkVersion == compileSdkVersion (latest SDK)</code><br>用较低的 minSdkVersion 来覆盖最大的人群，用最新的 SDK 设置 target 和 compile 来获得最好的外观和行为。</p>
<h3 id="01-13号-周三"><a href="#01-13号-周三" class="headerlink" title="01/13号  周三"></a>01/13号  周三</h3><p>清除数据：清除数据主要是清除用户配置，比如SharedPreferences、数据库等等，这些数据都是在程序运行过程中保存的用户配置信息，清除数据后，下次进入程序就和第一次进入程序时一样。<br>清除缓存：缓存是程序运行时的临时存储空间，它可以存放从网络下载的临时图片，从用户的角度出发清除缓存对用户并没有太大的影响，但是清除缓存后用户再次使用该APP时，由于本地缓存已经被清理，所有的数据需要重新从网络上获取，注意：为了在清除缓存的时候能够正常清除与应用相关的缓存，请将缓存文件存放在getCacheDir()或者 getExternalCacheDir()路径下。<br>一键清理：一键清理是系统级别的功能，它主要是杀后台进程，以达到释放内存的目的，但杀掉哪些进程和清理时设置的重要值阈值有关，重要值越大说明进程重要程度越低，如果在清理时某个进程的重要值大于该阈值，该进程就会被杀掉。<br><a href="http://zmywly8866.github.io/2015/03/22/difference-between-clear-data-clear-cache-clean-up.html" target="_blank" rel="external">明云的博客</a><br><code>getCacheDir()</code>方法用于获取<code>/data/data/&lt;application package&gt;/cache</code>目录<br><code>getFilesDir()</code>方法用于获取<code>/data/data/&lt;application package&gt;/files</code>目录<br>通过<code>Context.getExternalFilesDir()</code>方法可以获取到 <code>SDCard/Android/data/你的应用的包名/files/</code>目录，一般放一些长时间保存的数据<br>通过<code>Context.getExternalCacheDir()</code>方法可以获取到 <code>SDCard/Android/data/你的应用包名/cache/</code>目录，一般存放临时缓存数据<br>专门写一个方法来获取缓存地址<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDiskCacheDir</span><span class="params">(Context context)</span> </span>&#123;  </div><div class="line">    String cachePath = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())  </div><div class="line">            || !Environment.isExternalStorageRemovable()) &#123;  </div><div class="line">        cachePath = context.getExternalCacheDir().getPath();  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        cachePath = context.getCacheDir().getPath();  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> cachePath;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当SD卡存在或者SD卡不可被移除的时候，就调用<code>getExternalCacheDir()</code>方法来获取缓存路径，否则就调用<code>getCacheDir()</code>方法来获取缓存路径。前者获取到的就是 <code>/sdcard/Android/data/&lt;application package&gt;/cache</code>这个路径，而后者获取到的是 <code>/data/data/&lt;application package&gt;/cache</code>这个路径。</p>
<p><code>Ctrl+Shift+T</code>恢复google浏览器关闭后的整个卡页。</p>
<h3 id="01-16号-周六"><a href="#01-16号-周六" class="headerlink" title="01/16号  周六"></a>01/16号  周六</h3><p>直接用String拼接字符串时，编译器生成class文件时会自动优化为StringBuilder，但是是在每个循环体中实例化一次。性能上还是不如直接用StringBuilder拼接，因为直接用StringBuilder 循环体外部实例一次。</p>
<p> compile fileTree(dir: ‘libs’, include: ‘<em>.jar’) 正确<br> compile fileTree(dir: ‘libs’, include: [‘</em>.jar’]) 错误，此时坚果手机播放不了</p>
<h3 id="01-17号-周天"><a href="#01-17号-周天" class="headerlink" title="01/17号  周天"></a>01/17号  周天</h3><p>装饰者模式跟代理模式的区别：<br>装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。<br>我们可以用另外一句话来总结这些差别：使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。<br>装饰者的构造需要传入被装饰者的实例，而代理者不需要</p>
<h3 id="01-20号-周三"><a href="#01-20号-周三" class="headerlink" title="01/20号  周三"></a>01/20号  周三</h3><p>获取view的mLeft，mRight，mTop，mBottom。这几个左边啊都是相对父级view的，不是相对整个屏幕。分别通过方法getLeft()，getRight(),getTop(),getBottom()来获得。<br>3.0以后加入了x,y,translationX,translationY.view在平移过程中，top和left表示原始左上角的位置信息，不会变化的。x,y,translationX,translationY会随着移动变化，x，y表示移动后的坐标，translationX,translationY表示移动距离。x=left+translationX,y=top+translationY<br>在手机触摸屏幕时，产生一系列点击事件，通过MotionEvent对象我们可以得到点击事件发生的x，y坐标。系统提供了两组方法，getX/getY和getRawX/getRawY.区别是:getX/getY返回的是相对于当前view左上角的x和y左边，而getRawX/getRawY返回的是相对于手机屏幕左上角的x和y左标。<br>TouchSlop=ViewConfiguration.get(getContext()).getScaledTouchSlop(),是系统所能识别出的被认为是活动的最小距离。</p>
<p>gson解析之：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"files"</span>: &#123;</div><div class="line">    <span class="string">"Hello.txt"</span>: &#123;</div><div class="line">      <span class="string">"type"</span>: <span class="string">"text/plain"</span>,</div><div class="line">      <span class="string">"content"</span>: <span class="string">"Hello World!\n"</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="string">"created_at"</span>: <span class="string">"2014-05-27T02:31:35Z"</span>,</div><div class="line">  <span class="string">"updated_at"</span>: <span class="string">"2015-08-29T14:01:51Z"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>model class写为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Gist</span> </span>&#123;  </div><div class="line">  Map&lt;String, GistFile&gt; files;</div><div class="line">  Date createdAt;</div><div class="line">  Date updatedAt;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GistFile</span> </span>&#123;  </div><div class="line">  String type;</div><div class="line">  String content;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后<code>Gist gist = gson.fromJson(json, Gist.class);</code></p>
<p>gradle指定输出路径：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> outputPathName = <span class="string">"/Users/jjx/Downloads/Package/some.apk"</span></div><div class="line"><span class="comment">//这是应用编译完成</span></div><div class="line">applicationVariants.all &#123; variant -&gt;</div><div class="line">     variant.outputs.each  &#123; output -&gt;</div><div class="line">           <span class="comment">//开始输出</span></div><div class="line">           output.outputFile = <span class="keyword">new</span> File(outputPathName)</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>final空白，final变量声明的时候先不赋值，后续再赋值。但是一个final变量只能赋值一次。<br>final表示终态，在定义的时候哪怕给个null，一旦给定后就不可再更改。 所以变量尽量不要用null赋值。<br>对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象，这一点在编程中用到很多。<br><a href="http://lavasoft.blog.51cto.com/62575/18771" target="_blank" rel="external">http://lavasoft.blog.51cto.com/62575/18771</a><br><a href="http://www.importnew.com/6579.html" target="_blank" rel="external">http://www.importnew.com/6579.html</a></p>
<h3 id="01-22号-周五"><a href="#01-22号-周五" class="headerlink" title="01/22号  周五"></a>01/22号  周五</h3><p>alarmmanager是系统服务，设置以后不管你的app是否启动，都会定时发送广播。但是关机重启后alarmmanager就会被清除。像小米这种使用系统清理杀进程后，也会失效，但是这跟你app被杀死无关，这是因为小米系统清理后把三方app设置的定时清除掉了而已。<br><a href="http://stackoverflow.com/questions/8774030/alarmmanager-object-after-turning-off-and-on-the-phone" target="_blank" rel="external">http://stackoverflow.com/questions/8774030/alarmmanager-object-after-turning-off-and-on-the-phone</a><br>开机自启动服务<br><a href="http://stackoverflow.com/questions/6391902/how-to-start-an-application-on-startup" target="_blank" rel="external">http://stackoverflow.com/questions/6391902/how-to-start-an-application-on-startup</a></p>
<h3 id="01-27号-周三"><a href="#01-27号-周三" class="headerlink" title="01/27号  周三"></a>01/27号  周三</h3><p>Android studio 用Git提交的时候有shelve和stash选项，有什么不同呢。<br>不同就在于他们生成patches和应用patches的方式上：<br>stashed：changes生成patches是git自己做的，而且应用的时候，你不需要ide。<br>shelving：changes生成patches是ide帮你搞定的，应用patches也得需要ide，不用也是可行的，但你得额外做些操作。<br>rebase是新建的分支作为基线插到原基线前面，先把新分支的串行合并，再把原基线的合并，可能会需要解决多次冲突。<br>merge是按时间顺序捏合，解决一次冲突就好了。提交较多的时候最好用merge，不然用rebase会解决多次冲突。<br><a href="http://stackoverflow.com/questions/16666089/whats-the-difference-between-git-merge-and-git-rebase" target="_blank" rel="external">http://stackoverflow.com/questions/16666089/whats-the-difference-between-git-merge-and-git-rebase</a><br>路径相关<br>“.”  代表目前所在的目录。<br>“./SubDir2”  代表目前目录下的SubDir2。<br>“..”  代表上一层目录。<br>“/“  代表根目录。</p>

					</div>

			  <!-- about -->
			  
		</div>

		<!-- pagination -->
	  

		<div class="comment-section">
  
  
   <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="_posts/Notes-on-Tech-six.md" data-title="盗墓笔记（六）" data-url="http://jijiaxin89.com/2016/01/02/Notes-on-Tech-six/"></div>
    <!-- 多说评论框 end -->
   <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'jijiaxin'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  


</div>
	</div>

	

</div>


		<footer>
			

<p>
  由 <a href="https://hexo.io">hexo</a> 强力驱动 | 搭载 <a href="https://github.com/wayou/hexo-theme-material">material</a> 主题
</p>
<p>
  &copy; 2017 <a href="http://jijiaxin89.com"> 季訫 </a>
</p>
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	  </div>

		<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script>
		<script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>

		<!-- material design -->
		<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script>
		<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>
		<!-- toc -->
		<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script>
		<script src="/libs/tocify/jquery.tocify.custom.js"></script>

		<script src="/js/main.js"></script>

	</body>
</html>
